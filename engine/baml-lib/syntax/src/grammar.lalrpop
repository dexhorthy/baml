grammar<'err>(
    src_file: &SourceFile,
    diagnostics: &mut Diagnostics,
);

use crate::forms::class::{Class, Field};
use crate::pos::{mk_pos, empty_pos, WithPos};
use crate::forms::identifier::Identifier;
use crate::forms::r#type::{Type, BuiltinType};

use internal_baml_diagnostics::{DatamodelError, Diagnostics, SourceFile, Span};

use std::str::FromStr;


WithPos<Rule>: Rule = <l: @L> <t: Rule> <r: @R> => t.with_pos(mk_pos(src_file, l, r));

pub Identifier: Identifier<Span> = WithPos<BareIdentifier>;

BareIdentifier: Identifier<Span> = {
    <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => {
        Identifier{name: s.to_string(), meta: empty_pos(src_file)}
    }
};


// The syntax for a Class definition.
//
// ```baml
// class Foo {
//   foo int
//   bar string[]
// }
// ```
pub Class: Class<Span> = {
    <l: @L> "class" <name:Identifier> "{" <fields:FieldList> "}" <r: @R> => {
        let span = mk_pos(src_file, l,r);
        Class {
            name,
            fields,
            meta: span,
        }
    }
};

FieldList: Vec<Field<Span>> = {
    <fields:Field> => vec![fields],
    <mut fields:FieldList> <field:Field> => {
        fields.push(field);
        fields
    }
};

Field: Field<Span> = {
    <l: @L> <name:Identifier> <type_:Type> <r: @R> => {
        let span = mk_pos(src_file, l, r);
        Field {
            name,
            r#type: type_,
            meta: span,
        }
    }
};

PipeSep<T>: Vec<T> = {
    <mut v:(<T> "|")+> <e:T> => {
        v.push(e);
        v
    }
}

pub Type: Type<Span> = WithPos<BareType>;

BasicType: Type<Span> = {
    <base:Identifier> => match BuiltinType::from_str(base.to_string().as_str()) {
        Ok(builtin_type) => Type::Builtin { builtin_type, meta: empty_pos(src_file) },
        Err(_) => Type::UserDefined { name: base }
    }
};

ParenType: Type<Span> = {
    "(" <t:Type> ")" => t,
};

TypeAtom: Type<Span> = {
    BasicType,
    ParenType,
};

// Question mark operator can only be applied to type atoms.
// In other words, `int??` and `int[]?` are disallowed.
OptionType: Type<Span> = {
    <t:TypeAtom> "?" => {
        Type::Option { base_type: Box::new(t), meta: empty_pos(src_file) }
    },
    <l:@L> ! <r:@R> => {
        let span = mk_pos(src_file, l, r);
        diagnostics.push_error(DatamodelError::new_static("Can't ? a ?", span));
        Type::Error { meta: empty_pos(src_file )}
    }
};

ListType: Type<Span> = {
    <t:Type> "[" "]" => {
        Type::List { base_type: Box::new(t), meta: empty_pos(src_file) }
    }
};

UnionType: Type<Span> = {
    <first:TypeAtom> "|" <rest:TypeAtom> => {
        return Type::Union { variants: vec![first, rest], meta: empty_pos(src_file) };
    },
    <first:UnionType> "|" <rest:TypeAtom> => {
        match first {
            Type::Union { mut variants, meta } => {
                variants.push(rest);
                return Type::Union { variants, meta };
            }
            _ => unreachable!("The parser rules this out.")
        }
    }
};

pub BareType: Type<Span> = {
    TypeAtom,
    OptionType,
    ListType,
    UnionType,   
};

